//
// Created by dxy on 2020/8/25.
//

#include "environment.h"

#include "lex/lexer.h"
#include "lex/nfa.h"
#include "lex/token.h"

using namespace CCompiler;
using namespace std;

map<string, TokenType> Environment::regex_rules_{
        {"auto",                   TokenType::kAuto},
        {"break",                  TokenType::kBreak},
        {"case",                   TokenType::kCase},
        {"char",                   TokenType::kChar},
        {"const",                  TokenType::kConst},
        {"continue",               TokenType::kContinue},
        {"default",                TokenType::kDefault},
        {"do",                     TokenType::kDo},
        {"double",                 TokenType::kDouble},
        {"else",                   TokenType::kElse},
        {"enum",                   TokenType::kEnum},
        {"extern",                 TokenType::kExtern},
        {"float",                  TokenType::kFloat},
        {"for",                    TokenType::kFor},
        {"goto",                   TokenType::kGoto},
        {"if",                     TokenType::kIf},
        {"inline",                 TokenType::kInline},
        {"int",                    TokenType::kInt},
        {"long",                   TokenType::kLong},
        {"register",               TokenType::kRegister},
        {"restrict",               TokenType::kRestrict},
        {"return",                 TokenType::kReturn},
        {"short",                  TokenType::kShort},
        {"signed",                 TokenType::kSigned},
        {"sizeof",                 TokenType::kSizeof},
        {"static",                 TokenType::kStatic},
        {"struct",                 TokenType::kStruct},
        {"switch",                 TokenType::kSwitch},
        {"typedef",                TokenType::kTypedef},
        {"union",                  TokenType::kUnion},
        {"unsigned",               TokenType::kUnsigned},
        {"void",                   TokenType::kVoid},
        {"volatile",               TokenType::kVolatile},
        {"while",                  TokenType::kWhile},
        {"_Alignas",               TokenType::k_Alignas},
        {"_Alignof",               TokenType::k_Alignof},
        {"_Atomic",                TokenType::k_Atomic},
        {"_Bool",                  TokenType::k_Bool},
        {"_Complex",               TokenType::k_Complex},
        {"_Generic",               TokenType::k_Generic},
        {"_Imaginary",             TokenType::k_Imaginary},
        {"_Noreturn",              TokenType::k_Noreturn},
        {"_Static_assert",         TokenType::k_Static_assert},
        {"_Thread_local",          TokenType::k_Thread_local},
        {"[a-zA-Z_][a-zA-Z0-9_]*", TokenType::kIdentifier},
        {"(?:0|[1-9][0-9]*|(?:0x|0X)[0-9a-fA-F]+|0[0-7]+)(?:u|U|l|L)*",
                                   TokenType::kNumber},
        {"~",                      TokenType::kTilde},
        {"\\*",                    TokenType::kAsterisk},
        {"->",                     TokenType::kArrow},
        {"\\.",                    TokenType::kDot},
        {"\\?",                    TokenType::kQuestion},
        {"-",                      TokenType::kMinus},
        {"\\+",                    TokenType::kPlus},
        {"\\+\\+",                 TokenType::kIncrement},
        {"--",                     TokenType::kDecrement},
        {"/",                      TokenType::kDivide},
        {"%",                      TokenType::kModulo},
        {"=",                      TokenType::kAssign},
        {"<<",                     TokenType::kLeftShift},
        {">>",                     TokenType::kRightShift},
        {"<",                      TokenType::kLess},
        {">",                      TokenType::kMore},
        {"<=",                     TokenType::kLessEqual},
        {">=",                     TokenType::kMoreEqual},
        {"==",                     TokenType::kEqual},
        {"!=",                     TokenType::kNotEqual},
        {"&",                      TokenType::kAnd},
        {"\\|",                    TokenType::kOr},
        {"\\^",                    TokenType::kXor},
        {"&&",                     TokenType::kLogicalAnd},
        {"\\|\\|",                 TokenType::kLogicalOr},
        {"!",                      TokenType::kLogicalNot},
        {"\\*=",                   TokenType::kMultiAssign},
        {"/=",                     TokenType::kDivideAssign},
        {"%=",                     TokenType::kModuloAssign},
        {"\\+=",                   TokenType::kPlusAssign},
        {"-=",                     TokenType::kMinusAssign},
        {"<<=",                    TokenType::kLeftShiftAssign},
        {">>=",                    TokenType::kRightShiftAssign},
        {"&=",                     TokenType::kAndAssign},
        {"\\^=",                   TokenType::kXorAssign},
        {"\\|=",                   TokenType::kOrAssign},
        {"\\(",                    TokenType::kLeftParenthesis},
        {"\\)",                    TokenType::kRightParenthesis},
        {"\\[",                    TokenType::kLeftBracket},
        {"\\]",                    TokenType::kRightBracket},
        {"\\{",                    TokenType::kLeftCurlyBracket},
        {"\\}",                    TokenType::kRightCurlyBracket},
        {",",                      TokenType::kComma},
        {":",                      TokenType::kColon},
        {";",                      TokenType::kSemicolon},
        {R"(\.\.\.)",              TokenType::kEllipsis},
        {"#",                      TokenType::kNumberSign},
        {"\'",                     TokenType::kCharacter},
        {"\"",                     TokenType::kString},
        {"//|/\\*|\\*/",           TokenType::kComment},
        {R"((?:\n|\t|\r| )+)",     TokenType::kDelim}
};

void Environment::EnvironmentInit() {
  Lexer::nfa_ = Nfa(regex_rules_);
}